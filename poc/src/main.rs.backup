pub mod projector;
pub use projector::*;

pub mod scheme;
pub use scheme::*;

use ssccs_poc::core::{Field, Segment, SpaceCoordinates};
use ssccs_poc::spaces::{arithmetic::IntegerSpace, basic::BasicSpace};
use ssccs_poc::*;

// ==================== SSCCS CONSTITUTIONAL CONCEPT TESTS ====================

fn main() {
    println!("SSCCS Proof of Concept - Constitutional Concept Tests");
    println!("========================================================\n");
    
    // Run all concept tests
    let tests = vec![
        ("Segment Concept", test_segment_concept),
        ("Field Concept", test_field_concept),
        ("Projector Concept", test_projector_concept),
        ("Observation Concept", test_observation_concept),
        ("Space Concept", test_space_concept),
        ("Scheme Concept", test_scheme_concept),
        ("Integrated Workflow", test_integrated_workflow),
    ];
    
    let mut passed = 0;
    let mut failed = 0;
    
    for (test_name, test_func) in tests {
        println!("\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
        println!("â•‘ {:^40} â•‘", test_name);
        println!("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
        
        match test_func() {
            Ok(_) => {
                println!("\nâœ… {} PASSED", test_name);
                passed += 1;
            }
            Err(e) => {
                println!("\nâŒ {} FAILED: {}", test_name, e);
                failed += 1;
            }
        }
    }
    
    println!("\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
    println!("â•‘           TEST SUMMARY                      â•‘");
    println!("â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£");
    println!("â•‘ Passed: {:2} | Failed: {:2} | Total: {:2}     â•‘", passed, failed, passed + failed);
    println!("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    
    if failed == 0 {
        println!("\nðŸŽ‰ All SSCCS constitutional concepts validated successfully!");
    } else {
        println!("\nâš ï¸  {} concept test(s) failed. Review implementation.", failed);
        std::process::exit(1);
    }
}

// ==================== INDIVIDUAL CONCEPT TESTS ====================

/// Test 1: Segment Concept - Immutable coordinate existence
/// SSCCS Docs: "Segments are immutable points in possibility space"
fn test_segment_concept() -> Result<(), String> {
    // 1. Coordinate-based existence
    let coords = SpaceCoordinates::new(vec![1, 2, 3]);
    let segment = Segment::new(coords.clone());
    
    println!("1. Segment created from coordinates: {:?}", segment.coordinates().raw);
    println!("   Dimensionality: {}", segment.coordinates().dimensionality());
    
    // 2. Cryptographic identity
    let id = segment.id();
    println!("2. Cryptographic identity (BLAKE3): {:?}", hex::encode(id.as_bytes()));
    
    // 3. Same coordinates â†’ Same identity
    let segment2 = Segment::new(coords.clone());
    if segment.id() != segment2.id() {
        return Err("Segments with identical coordinates must have identical IDs".into());
    }
    println!("3. Identity consistency verified");
    
    // 4. Immutability verification
    println!("4. Immutability: No mutation methods available");
    println!("   - Segment coordinates are read-only");
    println!("   - Segment ID is computed once and immutable");
    
    // 5. Convenience constructors
    let single_val = Segment::from_value(42);
    let multi_val = Segment::from_values(vec![10, 20, 30]);
    println!("5. Convenience constructors:");
    println!("   - Single value segment: {:?}", single_val.coordinates().raw);
    println!("   - Multi-value segment: {:?}", multi_val.coordinates().raw);
    
    Ok(())
}

/// Test 3: Projector Concept - Semantic interpretation
/// SSCCS Docs: "Projector gives semantic meaning to combination of Field and Segment"
fn test_projector_concept() -> Result<(), String> {
    println!("1. Testing different projectors on same coordinates:");
    
    let segment = Segment::from_value(7);
    println!("   Segment coordinates: {:?}", segment.coordinates().raw);
    
    let empty_field = Field::new();
    
    // IntegerProjector
    let int_projector = IntegerProjector::new(0);
    let int_result = int_projector.project(&empty_field, &segment);
    println!("2. IntegerProjector result: {:?}", int_result);
    
    if int_result != Some(7) {
        return Err("IntegerProjector should extract coordinate value".to_string());
    }
    
    // ParityProjector  
    let parity_projector = ParityProjector;
    let parity_result = parity_projector.project(&empty_field, &segment);
    println!("3. ParityProjector result: {:?}", parity_result);
    
    if parity_result != Some("odd".to_string()) {
        return Err("ParityProjector should return \"odd\" for value 7".to_string());
    }
    
    // ArithmeticProjector
    let arith_projector = ArithmeticProjector;
    let arith_result = arith_projector.project(&empty_field, &segment);
    println!("4. ArithmeticProjector result: {:?}", arith_result);
    
    // Test adjacency semantics
    let next_coords = arith_projector.possible_next_coordinates(segment.coordinates());
    println!("5. ArithmeticProjector adjacency:");
    println!("   - Possible next coordinates: {:?}", next_coords.iter().map(|c| c.raw[0]).collect::<Vec<_>>());
    
    // Verify different semantic interpretations
    println!("6. Semantic interpretation verified:");
    println!("   - Same coordinates â†’ Different meanings");
    println!("   - Meaning emerges from projector, not coordinates");
    
    Ok(())
}

/// Test 4: Observation Concept - The sole active event
/// SSCCS Docs: "Observation is the only mechanism that produces actuality"
fn test_observation_concept() -> Result<(), String> {
    println!("1. Testing observation with constraint filtering:");
    
    let segment = Segment::from_value(5);
    let mut field = Field::new();
    field.add_constraint(RangeConstraint::new(0, 0, 10));
    
    let int_projector = IntegerProjector::new(0);
    
    // Observation with allowed coordinates
    let observation_result = observe(&field, &segment, &int_projector);
    println!("   - Observation result (allowed): {:?}", observation_result);
    
    if observation_result != Some(5) {
        return Err("Observation should succeed for allowed coordinates".to_string());
    }
    
    // Observation with disallowed coordinates
    let invalid_segment = Segment::from_value(15);
    let failed_observation = observe(&field, &invalid_segment, &int_projector);
    println!("   - Observation result (disallowed): {:?}", failed_observation);
    
    if failed_observation != None {
        return Err("Observation should fail for disallowed coordinates".to_string());
    }
    
    println!("2. Observation properties verified:");
    println!("   - Field constraints filter observations");
    println!("   - Projection is ephemeral (not cached)");
    println!("   - Re-observation required for same result");
    
    // Test possible_next_coordinates function
    let next_coords = possible_next_coordinates(&field, &segment, &ArithmeticProjector);
    println!("3. Possible next coordinates (filtered by field):");
    println!("   - {:?}", next_coords.iter().map(|c| c.raw[0]).collect::<Vec<_>>());
    
    Ok(())
}

/// Test 5: Space Concept - Structured coordinate spaces
/// SSCCS Docs: "Spaces provide structured access to coordinate systems"
fn test_space_concept() -> Result<(), String> {
    println!("1. BasicSpace - Multi-dimensional coordinates:");
    
    let coords = SpaceCoordinates::new(vec![1, 2, 3]);
    let basic_space = BasicSpace::new(coords.clone());
    
    println!("   - Created from coordinates: {:?}", basic_space.coordinates().raw);
    println!("   - ID: {:?}", hex::encode(basic_space.id().as_bytes()));
    
    // Test deref to Segment
    let segment_ref: &Segment = &basic_space;
    println!("   - Dereferences to Segment: {:?}", segment_ref.coordinates().raw);
    
    println!("\n2. IntegerSpace - Single-axis convenience:");
    
    let int_space = IntegerSpace::new(42);
    println!("   - Created from value: {:?}", int_space.coordinates().raw);
    println!("   - ID: {:?}", hex::encode(int_space.id().as_bytes()));
    
    // Test conversions
    let from_segment = IntegerSpace::from_segment(segment_ref.clone());
    println!("   - Converted from Segment");
    
    Ok(())
}

/// Test 6: Scheme Concept - Structural blueprint
/// SSCCS Docs: "Scheme is the immutable structural blueprint"
fn test_scheme_concept() -> Result<(), String> {
    println!("1. Creating 2D Grid Scheme:");
    
    let grid_scheme = Grid2DScheme::new(5, 5).to_scheme();
    println!("   - Scheme description: {}", grid_scheme.describe());
    println!("   - Scheme ID: {:?}", hex::encode(grid_scheme.id().as_bytes()));
    
    println!("\n2. Scheme properties:");
    println!("   - Dimensions: {}", grid_scheme.dimensionality());
    println!("   - Segment count: {}", grid_scheme.segments().count());
    
    // Test segment lookup
    let test_coords = SpaceCoordinates::new(vec![2, 2]);
    let test_segment = Segment::new(test_coords.clone());
    
    if grid_scheme.contains_segment(test_segment.id()) {
        println!("   - Contains segment at (2, 2)");
        
        // Memory mapping
        if let Some(addr) = grid_scheme.map_to_memory(&test_coords) {
            println!("   - Memory address for (2, 2): {}", addr);
        }
    }
    
    println!("\n3. Creating Integer Line Scheme:");
    
    let int_scheme = IntegerLineScheme::new(-5, 5).to_scheme();
    println!("   - Scheme description: {}", int_scheme.describe());
    println!("   - Segment count: {}", int_scheme.segments().count());
    
    Ok(())
}

/// Test 7: Integrated Workflow - Complete SSCCS pipeline
/// SSCCS Docs: "From structure to observation"
fn test_integrated_workflow() -> Result<(), String> {
    println!("1. Complete SSCCS workflow demonstration:");
    
    // Step 1: Create Scheme (structure)
    println!("\n   Step 1: Create structural blueprint");
    let scheme = IntegerLineScheme::new(0, 10).to_scheme();
    
    // Step 2: Select Segment from Scheme
    println!("   Step 2: Select Segment from blueprint");
    let segment = scheme.segments().nth(5).unwrap(); // Value 5
    println!("      - Selected segment: {:?}", segment.coordinates().raw);
    
    // Step 3: Configure Field (constraints)
    println!("   Step 3: Configure mutable Field");
    let mut field = Field::new();
    field.add_constraint(RangeConstraint::new(0, 0, 10));
    field.add_constraint(EvenConstraint::new(0));
    
    // Step 4: Choose Projector (semantics)
    println!("   Step 4: Choose semantic interpretation");
    let projector = ArithmeticProjector;
    
    // Step 5: Observe (collapse to actuality)
    println!("   Step 5: Observe (collapse constraint space)");
    let observation = observe(&field, segment, &projector);
    println!("      - Observation result: {:?}", observation);
    
    if observation != Some(5) {
        return Err("Observation should return value 5".to_string());
    }
    
    // Step 6: Explore possibilities
    println!("   Step 6: Explore possible transitions");
    let possibilities = possible_next_coordinates(&field, segment, &projector);
    println!("      - Filtered possibilities: {:?}", 
        possibilities.iter().map(|c| c.raw[0]).collect::<Vec<_>>());
    
    println!("\n2. Workflow verification:");
    println!("   âœ“ Structure defined by Scheme");
    println!("   âœ“ Constraints managed by Field");
    println!("   âœ“ Semantics provided by Projector");
    println!("   âœ“ Actuality produced by Observation");
    println!("   âœ“ Data movement minimized");
    
    Ok(())
}

/// Test 2: Field Concept - Mutable constraint substrate
/// SSCCS Docs: "Field is the only mutable layer. Contains constraints and relational topology."
fn test_field_concept() -> Result<(), String> {
    let mut field = Field::new();
    
    // 1. Constraint addition
    field.add_constraint(RangeConstraint::new(0, 0, 10));
    field.add_constraint(RangeConstraint::new(1, 0, 5));
    field.add_constraint(EvenConstraint::new(0));
    
    println!("1. Field constraints added:");
    println!("   - {}", field.describe_constraints());
    
    // 2. Constraint validation
    let valid_coords = SpaceCoordinates::new(vec![4, 3, 100]); // Even, within ranges
    let invalid_range = SpaceCoordinates::new(vec![15, 3, 0]);
    let invalid_even = SpaceCoordinates::new(vec![3, 2, 0]);
    
    println!("2. Constraint validation:");
    println!("   - Valid coords [4, 3, 100]: {}", field.allows(&valid_coords));
    println!("   - Invalid range [15, 3, 0]: {}", field.allows(&invalid_range));
    println!("   - Invalid even [3, 2, 0]: {}", field.allows(&invalid_even));
    
    if !field.allows(&valid_coords) {
        return Err("Valid coordinates should be allowed".to_string());
    }
    if field.allows(&invalid_range) {
        return Err("Coordinates out of range should be rejected".to_string());
    }
    if field.allows(&invalid_even) {
        return Err("Odd coordinates should be rejected by EvenConstraint".to_string());
    }
    
    // 3. Transition rules (relational topology)
    let from_coords = SpaceCoordinates::new(vec![1, 2, 3]);
    let to_coords = SpaceCoordinates::new(vec![2, 2, 3]);
    field.add_transition(from_coords.clone(), to_coords.clone(), 1.0);
    
    println!("3. Transition rules added:");
    println!("   - From [1, 2, 3] â†’ [2, 2, 3] with weight 1.0");
    
    let transitions = field.transition_targets(&from_coords);
    println!("   - Transition targets: {:?}", transitions.iter().map(|c| c.raw.clone()).collect::<Vec<_>>());
    
    if transitions.len() != 1 || transitions[0] != to_coords {
        return Err("Transition should return the correct target coordinates".to_string());
    }
    
    // 4. Field mutability demonstration
    println!("4. Field mutability demonstrated:");
    println!("   - Constraints can be added after creation");
    println!("   - Transition rules can be added dynamically");
    
    Ok(())
